\documentclass[10pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{multicol}
%\usepackage{setspace}
%\usepackage{amstext}
%\usepackage{amsmath}
%\usepackage{enumerate}
%\usepackage{graphicx}
%\usepackage{wrapfig}

\title{
	\textbf{
		Creating a Turn-Based Conflict Resolution Simulator FIX TEAMS INVADING A NODE
	}
}
\author{Noah Zimmt and Dakota Szabo}
\date{May 8, 2012}

\begin{document}
	\maketitle
	\begin{abstract}
		In this paper, we describe a territory-conquest simulation modeled on the classic board game RISK and present a parallelized method for efficiently simulating multiple rounds of the model. 
		Players compete on a gameboard represented by an undirected graph, with vertices and edges representing territories and their borders, respectively. 
		Using MPI, we distributed the computation and resolution of player actions between multiple compute nodes in order to acheive the speed neccessary to simulate massive games in a reasonable amount of time. 
		This was acheived via a randomized algorithm that partitioned the computational work between nodes, combined with by a pair of message-passing cycles that communicated the results of the computations to each node. 
		In performance testing, we found this method to scale reasonably with the size of the input graph, with expected variation depending on the graph shape (complete graphs performing better than stars, etc).
	\end{abstract}

	\begin{multicols}{2}
		\section*{Introduction}
		
		Our simulation models the popular domination game \emph{Risk}. 
		The map is laid out as a graph (a set of vertices and edges) in which each territory corresponds to a node in the graph and each border between territories corresponds to an edge between two nodes. 
		While the graphs we used to model simulations were complete graphs, the simulator is capable of simulating conflicts given any user-provided graph and set of initial troop count.  

		Each territory must manage its army (a collection of troops), placing troops on edges to attack other territories or defend itself against other territories. 
		Each territory belongs to a team; a territory will adopt its team's strategy for placing troops on edges, allowing the simulator to show how successful a strategy will be given graph shape and initial troop counts.

		The game is turn-based, with two stages comprising each turn: the decision stage and the resolution stage. 
		During the decision stage, each territory chooses to place troops on borders; a territory must choose how many of its troops are to be placed on each of its borders and what action (attack or defend) the collection of troops will perform on that border 
		During the resolution stage, each territory communicates its troop placements to each other territory, setting up the battle scenarios between bordering territories.  

		Battles occur 

		
		The synchronization stage handles territory takeovers (in which one territory's troops on a border conquer all of the other's troops, leading the conquered territory to potentially become a part of the conquering territory's team), troop reinforcements, and the communication of all updated team information and total troop counts from all territories to all other territories.

		The game terminates if, at the end of a turn, one of three conditions are met: either every territory is controlled by one team, there exists a single territory or no territory that has a nonzero number of troops remaining, or a user-supplied maximum number of turns has been reached.


		\section*{Related Work}
		Proin scelerisque urna et velit rutrum non feugiat nibh luctus. Aliquam posuere viverra lectus ut varius. Nam at erat tellus. Donec sed consectetur felis. Praesent at justo sit amet est vehicula pharetra viverra et magna. Nulla dignissim consectetur facilisis. Vestibulum a dui ligula. Nullam ornare sollicitudin molestie. Integer fringilla lacus ut metus lobortis mollis. Fusce magna velit, pulvinar a molestie vel, cursus et lorem. Phasellus semper pellentesque turpis eget faucibus. Proin at neque eu neque elementum sollicitudin vitae sit amet nunc. Etiam nec erat ut enim sagittis facilisis. Curabitur sollicitudin convallis arcu sit amet dignissim. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas.

		\section*{Implementation}
		To process events in parallel, each compute node must have a subset of the data used to represent the entire simulation.  
		Because the total amount of data being stored for the entire simulation grows exponentially with the size of the input graph, we partition the graph into sets of vertices, with each compute node being responsible for a given slice of the graph.  
		A compute node stores the team, total troop count, battle decisions, and battle resolutions for each of its vertices.
		Because each battle is fought over an edge, and an edge may connect two vertices whose data is contained on two different compute nodes, we elect a single compute node to be responsible for the battle that takes place on any given edge of the graph.
		Being that edge-coloring is known to be an NP-Complete problem, we devised an approximate solution for assigning battle computation to each compute node such that the work was resonable evenly distributed across all compute nodes: each territory flips a coin at the start of its turn; upon entering a battle, the coin flips are compared.  
		If the coin flips are the same, the compute node whose territory has a lower ID number is responsible for the calculation; otherwise, the other compute node is responsible.

		Our parallelized simulation models each game round in two main stages: an edge conflict stage and an internal vertex conflict stage.
		First, the edge conflict resolution stage determines and computes the outcomes of all battles that occurred during the round, with each battle taking place on an edge (a border between territories). 
		Because of the graph partitioning scheme, it was necessary to communicate a territory's battle stances to each of its bordering territories.  
		We did this using a round-robin inter-node communication method that enabled us to pass slices of a larger matrix of battle information to each node in turn; each compute node would scan the slice of battle data that it received, taking note of any important information about bordering territories engaging in battles with any of its territories.  
		Once all information was passed around, each compute node had enough information to compute the results for its share of battles for the turn (our coin-flip algorithm ensures that no computation is performed redundantly).  
		At this point in the turn, all battle information is decided. 
		To communicate this information back to the territories that it affects, we again utilize a round-robin data passing scheme that we refer to as the \emph{report card scheme}: each compute node creates and fills in a report card about all territories for which it is responsible.
		Each compute node then passes its report card to its right-hand neighbor (for the sake of simplicity, we visualize the compute nodes in a circular arrangement).  
		The neighbor then fills in information that it had computed about the first compute node's territories and passes the report card to its right. 
		This process continues until the report card arrives back at its owner, ensuring that at the end of the round-robin, each compute node's report card will have been filled in by each of the other compute nodes.
		
		Next, the internal vertex conflict resolution stage uses the data from the edge-conflict phase to decide which territories were conquered by which teams. 
		After all battles and takeovers are resolved, each compute node computes the total remaining number of troops in each territory and then decides which team now owns each territory that it is responsible for.
		At this point, each compute node has a new set of data about each of its territories; critical data such as team membership, total troop counts, and new coin flips for battle computation are distributed from each compute node to each other compute node via AllReduce.

		
		\section*{Rules and Regulations}
		

		
		
		\section*{Performance Analysis}
		Proin scelerisque urna et velit rutrum non feugiat nibh luctus. Aliquam posuere viverra lectus ut varius. Nam at erat tellus. Donec sed consectetur felis. Praesent at justo sit amet est vehicula pharetra viverra et magna. Nulla dignissim consectetur facilisis. Vestibulum a dui ligula. Nullam ornare sollicitudin molestie. Integer fringilla lacus ut metus lobortis mollis. Fusce magna velit, pulvinar a molestie vel, cursus et lorem. Phasellus semper pellentesque turpis eget faucibus. Proin at neque eu neque elementum sollicitudin vitae sit amet nunc. Etiam nec erat ut enim sagittis facilisis. Curabitur sollicitudin convallis arcu sit amet dignissim. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas.
		
		
		\section*{Conclusion}
		Nullam tortor mi, volutpat quis auctor non, aliquam id tellus. Morbi a massa libero, id tempus mi. Aliquam et sapien non est mollis interdum. Cras felis diam, luctus eget pellentesque ut, lacinia nec dui. Aenean eu orci neque, eu volutpat enim. Sed eleifend fringilla turpis, sed pharetra libero mollis non. Quisque ultrices, purus ut sagittis euismod, orci risus venenatis lacus, a auctor diam augue vitae dolor. Duis eleifend pulvinar enim ac mollis. Nulla auctor metus vel turpis consequat aliquam.
		
		\section*{Future Work}
		Quisque velit neque, ullamcorper non iaculis sed, ornare pellentesque nulla. In pharetra cursus imperdiet. Duis nulla justo, bibendum et consequat congue, condimentum et turpis. Sed tempus, odio ut posuere volutpat, quam lacus interdum odio, ac porttitor elit turpis vitae turpis. Mauris eu ultrices augue. Sed fermentum elementum tristique. Nam ipsum ipsum, rhoncus vitae cursus suscipit, volutpat eu felis.

	\end{multicols}
\end{document}